# HashMap部分源码笔记
## 1.计算底层容器容量方法
> 该方法主要将创建HashMap时传入的初始化容量转为2的n次幂
```
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}

```
* 假设tableSizeFor(211);
```
int n = cap - 1;       -1是防止cap本就是2的n次幂，-1后经过后续计算得到的还是数据本身


211二进制为 1101 0011
0000 0000 1101 0011    n |= n >>> 1;
0000 0000 0110 1001    | 操作
———————————————————
0000 0000 1111 1011    n |= n >>> 2;
0000 0000 0011 1110    | 操作 
———————————————————
0000 0000 1111 1111    n |= n >>> 4; 
0000 0000 0000 1111    | 操作
———————————————————
0000 0000 1111 1111    n |= n >>> 8; 
0000 0000 0000 0000    | 操作
———————————————————
0000 0000 1111 1111    n |= n >>> 16;
0000 0000 0000 0000    | 操作
———————————————————
0000 0000 1111 1111    结果 255

(n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; 最后这步判断最关键的一句 n + 1

0000 0000 1111 1111  255
0000 0000 0000 0001  +1
———————————————————
0000 0001 0000 0000  = 256 = 2^8


```
* 总结：所有的位移与|都是为了将高位以下数据改为1(只要n>0必定有一位为1)，当所有位上的数据为1时，则+1以后得到的数必定大于cap且是最接近cap的2的n次幂



## 参考
1. https://blog.csdn.net/huzhigenlaohu/article/details/51802457
2. https://juejin.im/post/5d51884ee51d4561e0516ac9
3. https://juejin.im/post/5d54300151882551d172f22d