# Java创建对象过程
## 1.整体流程
* new指令
* 加载字节码文件
* 为对象分配内存
* 将内存空间初始化为0
* 初始化对象内部值,如分代年龄、hash......
## 2.类加载
> 详情查看JVM类加载机制
## 3.为对象分配内存
* 根据字节码计算内存大小然后从java堆中机型分配
### 3.1 Java内存分配情况
* java堆内存相对规整：已使用与未使用划分清晰
* java堆内存不规整：已使用与未使用相互交错
### 3.1.1 内存分配方式一指针碰撞
> 内存堆为绝对规整，内存分配采用指针碰撞
* 在已使用内存与未使用内存中间存放一个指针作为分界点
* 当要存储对象是则指针向未使用内存的方向偏移，偏移的距离为对象的内存大小
### 3.1.2 内存分配方式——空闲列表
> 内存不规整则采用空闲列表
* 虚拟机维护着一个可用内存的列表，当存储对象时从内存列表中找出一块足够大的内存划分给对象并更新内存列表
### 3.2 对象在内存中的布局
### 3.2.1 对象头
> 它是实现synchronized的锁对象的基础，一般而言，synchronized使用的锁对象是存储在Java对象头里的，JVM中采用2个字来存储对象头(如果对象是数组则会分配3个字，多出来的1个字记录的是数组长度)，其主要结构是由Mark Word 和 Class MetadataAddress 组成
* Mark Word: 默认存储对象的hashCode,分代年龄,锁类型,锁标志位,偏向线程ID等信息
* Class MateData Address: 类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的数据
### 3.2.2 实例数据
> 存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐
### 3.2.1 对其填充
> 由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐，这点了解即可
## 4. 将内存空间初始化为零值
> 保证对象在使用时有默认值
## 5. 对对象进行必要的设置
> 设置元数据信息，分代年龄等

## static关键字
> 被static修饰的成员在相应的字节码文件加载时进行初始化，但也代表着被static修饰的成员无法访问对象的实例成员
## super关键字
> 父类的引用
* super指向父类，相应也可以通过super找到父类的成员
* 每个字类的构造函数内都应通过super调用父类的构造函数，如果没有则虚拟机会隐式创建    





## 参考
1. https://www.jianshu.com/p/1952061502d0

