# Redis高阶

## 1.Redis的数据类型
### 1.1 redisObject结构
> Redis的五大数据类型也称五大数据对象,Redis并没有直接使用这些结构来实现键值对数据库，而是使用这些结构构建了一个对象系统redisObject；这个对象系统包含了五大数据对象，字符串对象（string）、列表对象（list）、哈希对象（hash）、集合（set）对象和有序集合对象（zset）；而这五大对象的底层数据编码可以用命令OBJECT ENCODING来进行查看。
```c
typedef struct redisObject{
     //类型
     unsigned type:4;
     //编码
     unsigned encoding:4;
     //指向底层数据结构的指针
     void *ptr;
     //引用计数
     int refcount;
     //记录最后一次被程序访问的时间
     unsigned lru:22;
 
}robj
```
![](https://img2018.cnblogs.com/blog/1432634/201907/1432634-20190725142541285-2111600312.png)
### 1.1 String
> 字符串，最基本的数据类型，底层采用SDS来存储。SDS获取长度是O(n)的时间复杂度，redis在修改字符串时会对SDS自动扩容，防止了数据溢出，在修改时采用预分配内存和惰性释放空间的方式减少SDS内存的分配次数
### 1.2 Hash
> String作为key组成的hash表。底层使用hash表或压缩表作为数据结构。当发生hash冲突时使用拉链法解决冲突。
#### 1.2.1 编码转换规则 
> 当同时满足下面两个条件时，使用ziplist（压缩列表）编码：
* 列表保存元素个数小于512个
* 每个元素长度小于64字节
### 1.3 List
> 列表，按照String元素插入的顺序排序。redis底层采用双端链表和压缩列表来实现，双向链表记录了头尾指针与长度，压缩列表不在赘述。
#### 1.3.1 编码转换规则 
> 当同时满足下面两个条件时，使用ziplist（压缩列表）编码：
* 列表保存元素个数小于512个
* 每个元素长度小于64字节
### 1.4 Set
> String元素组成的无序集合，不允许重复,使用intset与hash实现
#### 1.4.1 编码转换规则
> 当有序集合对象同时满足以下两个条件时，对象使用 hash 编码：
* 集合对象中所有元素都是整数
* 列表保存元素个数小于512个
### 1.5 Sorted Set
> 与Set相似，但可以为集合中的元素进行排序，集合中每个元素拥有一个分数，通过分数为每个元素排序，
集合中的每个元素不可以重复，但是分数可以重复。底层采用跳跃表与压缩表实现。
#### 1.5.1 编码转换规则
> 当有序集合对象同时满足以下两个条件时，对象使用 ziplist 编码：
* 保存的元素数量小于128个
* 保存的所有元素长度都小于64字节

## 2.缓存与数据库一致性
## 2.1 更新还是删除缓存？
> 答案是删除，原因有三
* 存入的缓存并不一定是一个简单的值，而是经过复杂计算的，写入数据库后仍需要记录缓存是一种性能浪费
* 更新的缓存可能并一定被用到，频繁的更新也是性能浪费
* 脏数据
```
1.线程A更新了数据库
2.线程B更新了数据库
3.线程B更新了缓存
4.线程A更新了缓存
```
## 2.2 先删除缓存还是后删除缓存
### 2.2.1 先删除再更新数据库 
```
1.请求A进行写操作，删除缓存
2.请求B查询发现缓存不存在
3.请求B去数据库查询得到旧值
4.请求B将旧值写入缓存
5.请求A将新值写入数据库
```
### 2.2.2 先更新数据库再删除
> 这种方式由Faceboot提出，它解决了先删除再更新数据库脏数据的问题，原因就是更新数据库的操作的时间一般大于查询操作的时间
```
1.请求A进行写操作
2.请求B查询发现缓存不存在
3.请求B去数据库查询得到旧值
4.请求B将旧值写入缓存
5.请求A删除缓存
```
## 3. redis 集群
> 解决了单机QPS与内存不足的问题
### 3.1 数据分区

#### 3.1.1 顺序分区
> 根据机器数量顺序负责部分数据如：第一台负责1-33，第二台负责34-66，第三台负责67-100。顺序分区支持批量操作，且键值与业务相关，但容易出现数据倾斜。
> 估计hash函数后存入指定的机器中。数据分散度较高，无法顺序访问。
#### 3.1.2 哈希分区-节点取余分区
> 根据节点数取余进行分区，操作简单，但是后期扩容会造成大量的数据迁移，建议扩容时采用倍数扩容

* 优点
> 配置简单
* 缺点
> 数据节点伸缩时，导致迁移数据量较大
#### 3.1.2 哈希分区-一致性哈希分区
> 将所有的数据当做一个token环，token环中的数据范围是0到2的32次方。然后为每一个数据节点分配一个token范围值，这个节点就负责保存这个范围内的数据。存储时对每一个key进行hash运算，被哈希后的结果在哪个token的范围内，则按顺时针去找最近的节点，这个key将会被保存在这个节点上。

![](./images/cluster_hash.png)

* 优点
> 节点伸缩时，只影响邻近节点，但是还是有数据迁移
* 缺点
> 数据倾斜

#### 3.1.2 哈希分区-虚拟槽节点
> 虚拟槽分区是Redis Cluster采用的分区方式。预设虚拟槽，每个槽就相当于一个数字，有一定范围，每个槽映射一个数据子集，一般比节点数大。

![](./images/cluster_slot.png)

* 存储过程
1. 把16384槽按照节点数量进行平均分配，由节点进行管理
2. 对每个key按照CRC16规则进行hash运算
3. 把hash结果对16383进行取余
4. 把余数发送给Redis节点
5. 节点接收到数据，验证是否在自己管理的槽编号的范围
    如果在自己管理的槽编号范围内，则把数据保存到数据槽中，然后返回执行结果
    如果在自己管理的槽编号范围外，则会把数据发送给正确的节点，由正确的节点来把数据保存在对应的槽中
## 参考
1. https://juejin.im/post/5d7c7a14f265da03f47c4f93#heading-2
2. [底层数据结构](https://www.cnblogs.com/MouseDong/p/11134039.html)
3. https://www.cnblogs.com/ysocean/p/9102811.html#_label1
4. [数据库双写一致性](https://www.cnblogs.com/rjzheng/p/9041659.html)
5. [数据库双写一致性](https://juejin.im/post/5d7c7a14f265da03f47c4f93#heading-2)
