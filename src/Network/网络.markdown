# 网络基础
## OSI网络模型
1. 物理层
> 生活中的网线，光纤等，具体传输媒介，用于把已经转换为电信号的(0101....)网络数据通过物理设备传输到另一台电脑上，物理层定义了物理设备规范，接口等
2. 数据链路层
> 定义了物理层中电信号的分组，控制如何对物理介质的访问
3. 网络层
> 根据网络地址确定目标机器在网路中的位置
4. 传输层
> 用于对较大数据进行切分，保证数据到达目标机器的正确定
5. 会话层
> 
6. 表示层
> 
7. 应用层
> 规定发送方与接收的通信规则，如数据的发送方式，消息体的编码，消息体的大小等等

## TCP/IP
1. 定义
> TCP/IP模型是OSI网络模型的实现，TCP/IP模型是一些协议的统称如IP、ICMP、FTP、HTTP、TCP、UDP、IP等,
    TCP/IP模型并未按照OSI规范来实现，TCP/IP模型中的应用层代表着OSI中的应用、表示、会话这三层，链路层代表着
    OSI的物理、数据链路两层
## 浏览器输入URL之后的魔鬼操作
#### 浏览器解析URL
> http://segmentfault.com:443/a/1190000018265172
```
http://     segmentfault.com    443          /a/1190000018265172
协议         目标服务器          应用端口     资源路径
```
#### 生成HTTP消息
> 解析完URL就知道对哪个服务器进行什么操作，而HTTP协议就是规定了客户端与服务端交互的规则与步骤
##### 1. HTTP请求方式

> 告诉服务器我要对数据进行什么样的操作

* GET: 获取数据
* POST: 发送需要添加的新数据
* HEAD: 用于确认URI的有效性和获取资源的更新时间
* OPTIONS: 通知或查询通信选项，查询目标资源支持的方法
* PUT: 替换或更新数据
* DELETE: 删除数据
* TRACE: 不常用，追踪发出去的请求被代理或篡改的信息？？？
* CONNECT: 要求与服务器通信时建立隧道，实现同隧道进行TCP通信
##### 2. HTTP请求内容
> 请求内容一般包括两部分: 请求头部、请求主体
1. 请求头部
    * 请求行
        > 请求方法 请求URI HTTP版本
    * 请求首部字段
    * 通用首部字段
    * 实体首部字段
2. 报文主体
    * 数据
```
--请求行
GET /socket.io/?EIO=3&transport=polling&t=1550993494465-0 HTTP/1.1
--请求字段
Host: segmentfault.com:9443
Connection: keep-alive
.....

--报文主体
before=1550991948172&_=a99a10cf84b6d5edf9af65030538fd01
```
##### 3. HTTP响应内容
> 响应的报文一般包括两部分: 响应头部、响应主体
1. 响应头部
    * 状态行
    > HTTP版本 状态码
    * 响应首部字段
    * 通用首部字段
    * 实体首部字段
```
-- 状态行
HTTP/1.1 200 OK
-- 响应字段
Content-Type: text/html
Content-Length: 2
Access-Control-Allow-Credentials: true
Access-Control-Allow-Origin: https://segmentfault.com
Set-Cookie: io=zppo5ocTBTapjkv4ySrQ; Path=/; HttpOnly
Date: Sun, 24 Feb 2019 08:03:24 GMT
Connection: keep-alive

--响应主体
{status:ok}
```
##### 3. HTTP状态码
* 1xx: 请求正在被处理
* 2xx: 请求正常处理并且正常被响应
* 3xx: 重新定向等操作
* 4xx: 客户端错误
* 5xx: 服务端错误

#### HTTPS
* 从网络分层上面HTTPS比HTTP多了SSL(SSL or TLS)加密层, HTTP -> SSL or TLS -> TCP -> IP
* SSL
    1. 为网络通信提供安全及数据完整性的一种安全协议
    2. 是操作系统对外的API，SSL3.0根明为TSL
    3. 采用身份验证和数据加密保证网络通信的安全和数据的完整性
* 加密方式
    1. 对称加密: 加密和解密都使用的同一个秘钥
        > 假设客户端与服务端进行通信，为了安全起见，双方约定一种加密方式，具体的加密方式由第一次通信时进行传输
        * 缺点: 无法保证安全，可能第一次传输就被窃听
    2. 非对称加密: 加密使用的秘钥和解密使用的秘钥是不相同的
        > 假设服务端拥有公钥与私钥，被公钥加密的数据只能由私钥解密，服务端向外公布公钥，假设浏览器需要与服务端交互，则浏览器用公钥加密后将数据传递给
        服务端，服务端用私钥解密
        * 缺点: 浏览器无法确定公钥的安全性，换句话说，公钥可能被人可以替换，因此引出了第三方机构:CA
* CA(Certification Authority):
    1. 权威可信的认证机构
    2. CA颁发的证书中包括: 认证机构、证书的使用者、数字签名hash......
    3. 每个电脑里有自带了一些证书
* HTTPS具体加密过程(假设客户端与服务端进行通信)
    1. client向server发送请求
    2. server返回CA证书
    3. client接收到证书后用自己电脑里的证书进行验证(假设验证通过)，client用CA证书中server的公钥加密自己的私钥后发送
    4. server用私钥进行解密后得到client的私钥，此后client,server已经确定了对称加密的密钥，因此可以安全通信
    * 总结: HTTPS主要用CA公证非对称加密的密钥，非对称加密密钥确定传输对称加密的密钥，而后用对称加密通信，最后采用对称加密的原因是非对称加密的效率较低

#### 向DNS服务器查询URL的IP地址
> 假设公司的网络遵循TCP/IP的思路来设计，此时由一个根路由器通过集线器连接多个子路由器，子路由器下有多个主机(电脑)连接，所有的主机或者设备都会被分配一个IP地址
##### IP
> 从物理的角度来看，IP地址由32个比特位组成，8比特一组分为4组，每组用 . 连接，从网络的角度看IP地址分为网络号与主机号，网络号代表属于哪个子网，主机号则代表属于哪个主机
```
192.168.1.18
```
> 根据一串数字根本无法确定哪个属于网络号，哪个属于主机号，这两部分的结构也不固定，所以就需要另外的信息来指出这部分的具体分组: 子网掩码
##### 子网掩码
> 子网掩码的长度、分组与IP地址相同，子网掩码由两部分组成即左边与右边 - -，左边全部有1组成，右边全部由0组成
    1代表网络号的分组，0代表主机号的分组
```
255.255.255.0
```
```
          十进制            二进制
ip地址    10 .  1.  2.3     00001010.00000001.00000010.00000011
子网掩码  255.255.255.0     11111111.11111111.11111111.00000000
                相同即是1不同即是0 ↓↓↓
网络号    10 .  1.  2.      00001010.0000001.00000010.00000011
主机号                3
```
> 若主机号部分全部是0则ip地址指向的是一个子网，若主机部分全部是1则代表向子网所有设备发包，即广播
> 域名与IP地址的关系，IP字节少，便于传输，域名便于记忆
##### DNS查询
1. socket库
> 用于应用软件调用当前操作系统的网络功能，如浏览器并具备发送请求的功能，而是浏览器调用Ssocket库去发送
2. 解析器
> 位于socket中，生成向DNS服务器发送域名解析请求的信息，委托协议栈发送出去并接收DNS的查询(DNS返回给协议栈，协议栈返回给解析器)结果返回给应用程序
3. 协议栈
> 操作系统中的网络控制软件，也叫协议驱动，TCP/IP驱动
4. DNS
#### TCP
> 面向连接的，可靠，基于字节流传输的协议，接收应用层的数据并进行适当的分割，把分割好的数据传递给IP网络模块
1. TCP报文头部

![](./tcp-header.png)

* 源端口
* 目标端口
* 位序号(Seq): 数据开始的序号，告诉数据接收方，当前数据位于所有数据的第几字节，位序号随机产生，防止非法者拦截请求对数据进行篡改
* 确认序号(ACK acknowladge): 下一个数据保的序号，根据序号将全部数据进行拼装
* 首部长度(offset): 当前数据段与数据的第一个字节的偏移量
* 控制位(TCP Flags):
    1. URG: 紧急指针，为1时启动紧急指针
    2. ACK: 确认序号标志,表示接受数据序号字段有效，1:确认，0:无效
    3. PSH: 代表尽快将数据保传递给应用程序
    4. RST: 重置链接标志，用于重置链接或拒绝非法的链接
    5. SYN: 同步序号，发送方与接收方相互确认序号，用于建立链接，SYN=1时表示链接，SYN=1只在链接时出现，因此发送SYN=1的网络包就表示发起连接的意思
    6. FIN: 关闭链接标志，为1时表示发送方无数据发送，准备关闭
* 窗口: 缓存发送方的数据，控制发送方的发送频率
* 校验和: 检查是否出现错误
* 紧急指针: 当控制为URG为1时有效
##### TCP收发数据
* 三次握手连接
    ![](./tcp-connect.png)
    
    1. 建立链接时，客户端发送数据包到服务器，其中TCP头部的SYN=1表示进行连接，Seq=随机数初始值，并进入SYN_SEND状态，等待服务器确认
    2. 服务器收到SYN包，同时自己也发送一个SYN包(SYN=1,ACK=1,Seq=随机数初始值,ack=j+1，j+1的意思是 j+1之前的数据已经确认)，
        即SYN+ACK包，此时服务器进入SYN_RECV状态
    3. 客户端收到服务器的SYN+ACK包，向服务器发送确认包(ack=k+1),客户端和服务器进入ESTAB-LISHED状态，完成三次握手
* 数据收发
    1. 客户端向服务端发送序号+数据，假设序号=101
    2. 服务端计算数据包，数据包总长度 - 数据头长度 = 数据长度，假设数据长为1200，服务端回复客户端ACK包，其中ack=1301,表示1301字节之前的数据已经确认
    3. ......
    4. 直到数据全部发送完毕，服务端向客户端发送数据也是一样，如果在发送中途出现异常，TCP会重新发送，如果重试几次后仍失败则TCP向上层抛出异常
* ACK优化
> 每发送一个数据包，就会接受一个ACK来确认前一个发送的正确性，当长时间没有接收到ACK时则需要重发，如果多次重发会导致网路的阻塞，所以应选取一种合适的时间点来重发
    而等待ACK的时间因网络原因不可固定,则TCP采用动态测量时间的方法，TCP会持续加检测ACK的返回时间而动态的调整ACK等待时间
* 滑动窗口
> TCP采用滑动窗口来管理收发数据与ACK号,如果发送方在没有收到接收方的ACK就一直等待这样会浪费资源，滑动窗口就是发送方不等待接收方的ACK，而是直接发送一系类的数据包，
    接收方接收到数据后会把数据放进缓冲区，为了防止数据过多导致缓冲区内存溢出，接收方会在TCP头部的窗口字段告知发送方字节的缓存大小，发送方每次发送数据时自行计算出接收方缓冲区大小进行发送的调整，
    接收方在接收到数据时并不会立即发送ACK，而是等待一段时间，此时缓冲区的数据会被处理，处理成功则将此数据在缓冲区移除，释放缓冲区，接收方在等待一段时间后查看换冲区的剩余大小是否被更新，如果更新则
    将ACK与缓冲区的剩余量一起发送给接收方
* 四次挥手
> 假设通信结束，服务端发起断开请求为例(客户端发起断开的操作与服务端一样), 服务端用用程序调用socket库的close方法来结束收发操作并通知TCP模块生成TCP断开的头部
1. TCP头部的控制位FIN设置为1并发送给客户端
2. 客户端返回ACK号告知服务端FIN=1的数据包已经接收到
3. 协议栈等待应用程序来读取数据时告知应用程序来自服务端的数据全部接受完毕，应用程序调用socket库的close来结束收发操作并通知TCP模块生成TCP断开的头部并发送，其中TCP头部控制位FIN=1,
4. 服务端接收到客户端FIN=1的数据包执行断开操作
* 为什么需要三次握手与四次挥手
    1. 三次握手是建立可靠连接最基本的要求，2次握建立的不可靠，4次握手用来建立基本可靠的连接有些多余
    2. 四次挥手则是安全断开连接的基本要求，三次或者五次也可以断开，但代表着不安全断开或发送多余数据包
##### 协议栈发送数据的时机
* MTU: MTU表示以太网中网络包的最大长度，一般为1500字节
* MSS: 去除头部后一个网络包所能容纳TCP数据最大长度
> 协议栈接收到应用程序的数据后并不会马上发送出去，而是存在缓冲区，原因协议栈并不知道应用程序发送多少数据，不同的应用程序传递给协议栈数据的方式也不同，有的是
    一次全部传递，有的是逐字节传递，有的是逐行传递，因此协议栈不会接收到数据就发送，防止出现发送大量的小数据保，协议栈具体发送的时机根据数据包的大小与时间，一种情况
    是当数据将MSS填充满了发出去，在一个是协议栈内有计时器，时间过长时将发送数据，两者具体的平衡点根据不同的系统有部分的差异，最后协议栈也可将发送数据的控制权交由应用程序去判断，
    是立即发送还是延迟发送
#### UDP
* 特点
    1. 面向非链接
    2. 支持多个客户端传输相同的消息
    3. 数据包包头只有8字节
    4. 吞吐量只受限于数据生成速率，传输速率机器性能
    5. 尽最大努力交付，不保证可靠交付，不需要维护负载的链接状态
    6. 面向报文，不对应用程序的数据进行拆分或者合并
    
#### TCP与UDP的区别
* 面向连接VS无连接
* TCP具有可靠性与有序性而UDP都不具备
* TCP较慢，UDP较快
* TCP头的字节数较大属于轻量级，UDP头只有8字节，属于轻量级
## 参考
1. http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html
2. 图解HTTP
3. 网络是怎样连接的(力荐!)
4. https://juejin.im/post/5a7146fd51882573351a9d99
5. https://yuqirong.me/2018/03/03/HTTPS%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/
